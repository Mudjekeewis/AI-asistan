<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Asistan - WebRTC Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            max-width: 500px;
            width: 100%;
            text-align: center;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 30px;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .status.connecting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .mic-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 10px;
            background: #f8f9fa;
        }

        .mic-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }

        .mic-indicator.active {
            background: #28a745;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .transcript-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            background: #f8f9fa;
            margin-bottom: 20px;
            text-align: left;
        }

        .transcript-title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }

        .transcript-text {
            line-height: 1.6;
            color: #666;
            white-space: pre-wrap;
        }

        .error-message {
            color: #dc3545;
            margin-top: 10px;
            font-size: 14px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">ü§ñ AI Asistan</div>
        
        <div id="status" class="status connecting">
            <span id="statusText">Baƒülanƒ±yor...</span>
            <div class="loading" id="loading"></div>
        </div>

        <div class="mic-status">
            <div id="micIndicator" class="mic-indicator"></div>
            <span id="micText">Mikrofon izni bekleniyor</span>
        </div>

        <div class="controls">
            <button id="connectBtn" class="btn btn-primary">Baƒülan</button>
            <button id="disconnectBtn" class="btn btn-danger" disabled>Dur</button>
        </div>

        <div class="transcript-container">
            <div class="transcript-title">üìù Canlƒ± Transkript</div>
            <div id="transcriptText" class="transcript-text">G√∂r√º≈üme ba≈üladƒ±ƒüƒ±nda transkript burada g√∂r√ºnecek...</div>
        </div>

        <div id="errorMessage" class="error-message"></div>
    </div>

    <script>
        class WebRTCClient {
            constructor() {
                this.ws = null;
                this.peerConnection = null;
                this.localStream = null;
                this.callId = this.getCallIdFromUrl();
                this.transcript = '';
                
                this.initializeElements();
                this.bindEvents();
            }

            getCallIdFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('call_id');
            }

            initializeElements() {
                this.statusElement = document.getElementById('status');
                this.statusText = document.getElementById('statusText');
                this.loadingElement = document.getElementById('loading');
                this.micIndicator = document.getElementById('micIndicator');
                this.micText = document.getElementById('micText');
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.transcriptText = document.getElementById('transcriptText');
                this.errorMessage = document.getElementById('errorMessage');
                
                // Remote audio element'ini √∂nceden olu≈ütur
                this.remoteAudio = document.createElement('audio');
                this.remoteAudio.autoplay = true;
                this.remoteAudio.playsInline = true;
                this.remoteAudio.muted = false;
                document.body.appendChild(this.remoteAudio);
            }

            bindEvents() {
                console.log('üîó Event listener\'lar baƒülanƒ±yor...');
                console.log('üîó Connect button:', this.connectBtn);
                console.log('üîó Disconnect button:', this.disconnectBtn);
                
                this.connectBtn.addEventListener('click', async () => {
                    console.log('üîò Baƒülan butonuna tƒ±klandƒ±!');
                    console.log('üîò This context:', this);
                    console.log('üîò Connect method:', this.connect);
                    await this.remoteAudio.play().catch(() => {});
                    try {
                        await this.connect();
                    } catch (error) {
                        console.error('üîò Connect √ßaƒürƒ±sƒ±nda hata:', error);
                    }
                });
                this.disconnectBtn.addEventListener('click', () => {
                    console.log('üîò Dur butonuna tƒ±klandƒ±!');
                    this.disconnect();
                });
                
                console.log('‚úÖ Event listener\'lar baƒülandƒ±');
            }

            async connect() {
                try {
                    console.log('üöÄ Connect fonksiyonu ba≈üladƒ±');
                    this.updateStatus('connecting', 'Baƒülanƒ±yor...');
                    this.showError('');

                    console.log('üé§ Mikrofon izni alƒ±nƒ±yor...');
                    await this.getMicrophonePermission();
                    console.log('üé§ Mikrofon izni alƒ±ndƒ±, localStream:', this.localStream);

                    console.log('üîë Token alƒ±nƒ±yor...');
                    const token = await this.getWebRTCToken();
                    console.log('üîë Token alƒ±ndƒ±:', token);

                    console.log('üîå WebSocket baƒülantƒ±sƒ± kuruluyor...');
                    await this.connectWebSocket(token);
                    console.log('üîå WebSocket baƒülandƒ±, ws:', this.ws);

                    console.log('üåê WebRTC ba≈ülatƒ±lƒ±yor...');
                    await this.initializeWebRTC();
                    console.log('üåê WebRTC ba≈ülatƒ±ldƒ±, peerConnection:', this.peerConnection);

                    this.updateStatus('connected', 'Baƒülandƒ±');
                    this.connectBtn.disabled = true;
                    this.disconnectBtn.disabled = false;

                } catch (error) {
                    console.error('‚ùå Connection error:', error);
                    this.showError(`Baƒülantƒ± hatasƒ±: ${error.message}`);
                    this.updateStatus('error', 'Baƒülantƒ± hatasƒ±');
                }
            }

            async getMicrophonePermission() {
                try {
                    console.log('üé§ Mikrofon izni isteniyor...');
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });
                    
                    console.log('‚úÖ Mikrofon stream alƒ±ndƒ±:', this.localStream);
                    console.log('‚úÖ Track sayƒ±sƒ±:', this.localStream.getTracks().length);
                    
                    this.micIndicator.classList.add('active');
                    this.micText.textContent = 'Mikrofon aktif';
                } catch (error) {
                    console.error('‚ùå Mikrofon izni hatasƒ±:', error);
                    throw new Error('Mikrofon izni verilmedi');
                }
            }

            async getWebRTCToken() {
                const response = await fetch(`/api/rtc/token?call_id=${this.callId}`);
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.message || 'Token alƒ±namadƒ±');
                }
                
                return data.data.token;
            }

            connectWebSocket(token) {
                return new Promise((resolve, reject) => {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/rtc?call_id=${this.callId}`;
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        resolve();
                    };

                                         this.ws.onmessage = (event) => {
                         console.log('üì® Raw WebSocket message received');
                         console.log('üì® Raw data:', event.data);
                         console.log('üì® This context:', this);
                         console.log('üì® Client instance:', window.client);
                         
                         try {
                             const message = JSON.parse(event.data);
                             console.log('üì® Parsed message:', message);
                             
                             // Global client instance'ƒ±nƒ± kullan
                             if (window.client) {
                                 window.client.handleWebSocketMessage(message);
                             } else {
                                 console.error('‚ùå Client instance not found!');
                             }
                         } catch (error) {
                             console.error('üì® Error parsing message:', error);
                         }
                     };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        reject(new Error('WebSocket baƒülantƒ± hatasƒ±'));
                    };

                    this.ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.handleDisconnection();
                    };
                });
            }

            async initializeWebRTC() {
                this.peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                });

                this.peerConnection.addTransceiver('audio', { direction: 'sendrecv' });

                this.localStream.getTracks().forEach(track => {
                    this.peerConnection.addTrack(track, this.localStream);
                });

                this.peerConnection.ontrack = (event) => {
                    console.log('üîä Received audio track from OpenAI');
                    this.remoteAudio.srcObject = event.streams[0];
                    this.remoteAudio.play().catch(e => console.warn('autoplay blocked?', e));
                };

                this.peerConnection.oniceconnectionstatechange = () =>
                    console.log('iceConnectionState:', this.peerConnection.iceConnectionState);
                this.peerConnection.onconnectionstatechange = () =>
                    console.log('connectionState:', this.peerConnection.connectionState);

                // üî∏ Data channel - OpenAI Realtime i√ßin kritik!
                this.eventsDc = this.peerConnection.createDataChannel("oai-events");
                this.eventsDc.onopen = () => {
                    console.log("oai-events channel OPEN");
                    
                    this.eventsDc.send(JSON.stringify({
                        type: "response.create",
                        response: {
                            instructions: "Merhaba, ben Zeynep. Kƒ±sa tanƒ±tƒ±m yap ve KVKK onayƒ± sor.",
                            modalities: ["audio"]
                        }
                    }));
                };
                
                this.eventsDc.onmessage = (e) => {
                    try {
                        const evt = JSON.parse(e.data);
                        if (evt.type === "response.completed" || evt.type === "conversation.item.completed") {
                            console.log("LLM event:", evt.type);
                        }
                    } catch (error) {
                        console.log('Data channel message:', e.data);
                    }
                };

                const offer = await this.peerConnection.createOffer();
                await this.peerConnection.setLocalDescription(offer);

                await new Promise((resolve) => {
                    if (this.peerConnection.iceGatheringState === 'complete') return resolve();
                    const check = () => {
                        if (this.peerConnection.iceGatheringState === 'complete') {
                            this.peerConnection.removeEventListener('icegatheringstatechange', check);
                            resolve();
                        }
                    };
                    this.peerConnection.addEventListener('icegatheringstatechange', check);
                    setTimeout(resolve, 2000);
                });

                console.log('ICE gathering completed, sending offer...');

                this.ws.send(JSON.stringify({
                    type: 'client-offer',
                    call_id: parseInt(this.callId),
                    sdp: this.peerConnection.localDescription.sdp
                }));
            }

                         async handleWebSocketMessage(message) {
                 console.log('WebSocket message:', message);
                 console.log('Message type:', message.type);
                 console.log('Full message:', JSON.stringify(message, null, 2));

                 switch (message.type) {
                     case 'status':
                         this.updateStatus(message.status === 'in-progress' ? 'connected' : 'connecting', 
                                         message.status === 'in-progress' ? 'G√∂r√º≈üme aktif' : 'Baƒülanƒ±yor...');
                         break;
 
                     case 'session-ready':
                         console.log('üéØ Session ready received:', message.session);
                         console.log('üîÑ Starting OpenAI connection...');
                         console.log('Session data:', JSON.stringify(message.session, null, 2));
                         
                         // Manuel test i√ßin
                         if (window.testOpenAI) {
                             console.log('üß™ Calling manual test...');
                             window.testOpenAI(message.session);
                         }
                         
                         try {
                             console.log('üîó Calling connectToOpenAI...');
                             await this.connectToOpenAI(message.session);
                         } catch (error) {
                             console.error('‚ùå OpenAI connection failed:', error);
                             this.showError(`OpenAI baƒülantƒ± hatasƒ±: ${error.message}`);
                         }
                         break;

                    case 'transcript.delta':
                        this.transcript += message.text;
                        this.updateTranscript();
                        break;

                    case 'transcript.final':
                        this.transcript += message.text + '\n';
                        this.updateTranscript();
                        break;

                    case 'audio.data':
                        this.playTTSAudio(message.audio);
                        this.transcript += message.text;
                        this.updateTranscript();
                        break;

                    case 'summary.ready':
                        this.transcript += `\n\nüìä √ñZET:\n${JSON.stringify(message.summary, null, 2)}\n`;
                        this.transcript += `Duygu: ${message.sentiment}\n`;
                        this.transcript += `Sƒ±caklƒ±k: ${message.score_hotness}/100\n`;
                        this.updateTranscript();
                        break;

                    case 'error':
                        this.showError(message.message);
                        break;
                }
            }

                         async connectToOpenAI(sessionData) {
                 try {
                     console.log('üîó Connecting to OpenAI Realtime...');
                     console.log('üìã Session data:', sessionData);
                     console.log('üìÑ Local description:', this.peerConnection.localDescription);
                     console.log('üéØ PeerConnection state:', this.peerConnection.connectionState);
                    
                    const resp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(sessionData.model)}`, {
                        method: "POST",
                        headers: {
                            "Authorization": `Bearer ${sessionData.client_secret.value}`,
                            "Content-Type": "application/sdp",
                            "OpenAI-Beta": "realtime=v1"
                        },
                        body: this.peerConnection.localDescription.sdp
                    });
                    
                                         console.log('üì° OpenAI response status:', resp.status);
                     
                     if (!resp.ok) {
                         const errorText = await resp.text();
                         console.error('‚ùå OpenAI error response:', errorText);
                         throw new Error(`OpenAI Realtime error: ${resp.status} - ${errorText}`);
                     }
                     
                     const answerSdp = await resp.text();
                     console.log('üì• Received answer SDP:', answerSdp.substring(0, 200) + '...');
                    
                                         await this.peerConnection.setRemoteDescription({ 
                         type: "answer", 
                         sdp: answerSdp 
                     });
                     
                     console.log('‚úÖ Connected to OpenAI Realtime successfully!');
                     console.log('üéµ Waiting for audio track...');
                    
                } catch (error) {
                    console.error('Error connecting to OpenAI Realtime:', error);
                    this.showError(`OpenAI baƒülantƒ± hatasƒ±: ${error.message}`);
                }
            }

            playTTSAudio(base64Audio) {
                try {
                    const audioData = atob(base64Audio);
                    const audioArray = new Uint8Array(audioData.length);
                    for (let i = 0; i < audioData.length; i++) {
                        audioArray[i] = audioData.charCodeAt(i);
                    }

                    const audioBlob = new Blob([audioArray], { type: 'audio/mpeg' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    const audio = new Audio(audioUrl);
                    audio.volume = 0.8;
                    
                    audio.onended = () => {
                        URL.revokeObjectURL(audioUrl);
                    };
                    
                    audio.play().catch(error => {
                        console.error('Error playing TTS audio:', error);
                    });

                } catch (error) {
                    console.error('Error processing TTS audio:', error);
                }
            }

            updateTranscript() {
                this.transcriptText.textContent = this.transcript;
                this.transcriptText.scrollTop = this.transcriptText.scrollHeight;
            }

            updateStatus(status, text) {
                this.statusElement.className = `status ${status}`;
                this.statusText.textContent = text;
                this.loadingElement.style.display = status === 'connecting' ? 'inline-block' : 'none';
            }

            showError(message) {
                this.errorMessage.textContent = message;
            }

            handleDisconnection() {
                this.updateStatus('error', 'Baƒülantƒ± koptu');
                this.connectBtn.disabled = false;
                this.disconnectBtn.disabled = true;
                this.micIndicator.classList.remove('active');
                this.micText.textContent = 'Baƒülantƒ± koptu';
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                }
                if (this.peerConnection) {
                    this.peerConnection.close();
                }
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                }
                
                this.handleDisconnection();
            }
        }

                 document.addEventListener('DOMContentLoaded', () => {
             console.log('üöÄ DOMContentLoaded triggered');
             const client = new WebRTCClient();
             console.log('üîß WebRTCClient created:', client);
             
             // Global eri≈üim i√ßin
             window.client = client;
             window.WebRTCClient = WebRTCClient;
             console.log('üåê Global objects set:', { client: window.client, WebRTCClient: window.WebRTCClient });
             
                           // Global test fonksiyonu
              window.testConnect = () => {
                  console.log('üß™ Manuel connect testi ba≈ülatƒ±lƒ±yor...');
                  window.client.connect();
              };
              
              window.testOpenAI = async (sessionData) => {
                 console.log('üß™ Manual OpenAI test starting...');
                 try {
                     const resp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(sessionData.model)}`, {
                         method: "POST",
                         headers: {
                             "Authorization": `Bearer ${sessionData.client_secret.value}`,
                             "Content-Type": "application/sdp",
                             "OpenAI-Beta": "realtime=v1"
                         },
                         body: "v=0\r\no=- 1234567890 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\na=group:BUNDLE 0\r\na=msid-semantic: WMS\r\nm=audio 9 UDP/TLS/RTP/SAVPF 111\r\nc=IN IP4 0.0.0.0\r\na=mid:0\r\na=sendrecv\r\na=rtpmap:111 opus/48000/2\r\n"
                     });
                     
                     console.log('üß™ Test response status:', resp.status);
                     if (resp.ok) {
                         const answer = await resp.text();
                         console.log('üß™ Test answer received:', answer.substring(0, 100));
                     } else {
                         const error = await resp.text();
                         console.error('üß™ Test error:', error);
                     }
                 } catch (error) {
                     console.error('üß™ Test failed:', error);
                 }
             };
         });
    </script>
</body>
</html> 
